# Implementation Plan: ClipForge Desktop Video Editor

**Branch**: `001-clipforge` | **Date**: 2025-10-27 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-clipforge/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command and guides implementation from requirements to working code.

## Summary

ClipForge is a native desktop video editor that enables creators to record (screen/webcam), import video files, edit on a timeline, and export professional videos. The MVP focuses on import → edit → export workflow, with recording and advanced features in subsequent phases. Built with Tauri for native performance, Svelte for reactive UI, and FFmpeg for media processing.

**Technical Approach**: Tauri provides cross-platform desktop capabilities with Rust backend for performance-critical operations (FFmpeg integration, file I/O, system APIs). Svelte frontend delivers reactive timeline UI with HTML5 Canvas for efficient rendering. Media processing leverages FFmpeg CLI invoked from Rust for transcoding, export, and effects.

## Technical Context

**Language/Version**: Rust 1.75+ (Tauri backend), TypeScript 5.0+ with Svelte 4.0+ (frontend)

**Primary Dependencies**:
- **Tauri 1.5+**: Desktop framework (Rust backend + web frontend)
- **Svelte 4.0+**: Reactive frontend framework
- **FFmpeg 6.0+**: Media processing (CLI invoked from Rust)
- **HTML5 Canvas API**: Custom timeline renderer
- **HTML5 Video Element**: Video preview and playback
- **tokio**: Async runtime for Rust (FFmpeg process management)
- **serde**: Rust serialization for Tauri commands
- **tauri-plugin-fs-extra**: Enhanced filesystem operations
- **tauri-plugin-dialog**: Native file picker dialogs

**Storage**: 
- **Project files**: JSON format storing timeline state, clip references, edit decisions (stored on local filesystem)
- **Media cache**: Thumbnail images and proxy videos (SQLite database for metadata, files on disk)
- **Auto-save**: Periodic JSON snapshots to prevent data loss

**Testing**:
- **Rust backend**: `cargo test` for unit tests, integration tests for FFmpeg pipelines
- **Frontend**: Vitest for component tests, Playwright for E2E tests
- **CI/CD**: GitHub Actions with platform-specific runners (macOS, Windows)

**Target Platform**: 
- **Primary**: macOS 11+ (Intel + Apple Silicon)
- **Secondary**: Windows 10+ (x64)
- **Future**: Linux (Ubuntu 20.04+)

**Project Type**: Desktop application (Tauri hybrid architecture - Rust + Svelte frontend)

**Performance Goals**:
- Timeline UI: 60 fps rendering, sub-100ms interaction response
- Video playback: 30+ fps for 1080p, 24+ fps for 4K
- Export: Real-time encoding (1 minute video exports in ~1 minute at 1080p)
- App launch: Under 5 seconds cold start
- Memory: Under 2GB for typical editing sessions

**Constraints**:
- Cross-platform: Must build and run identically on macOS and Windows
- Offline-first: No network requirements for core editing (cloud export optional)
- Native performance: Timeline must handle 50+ clips without lag
- Disk I/O: Efficient caching to minimize SSD wear during scrubbing
- FFmpeg bundling: Ship static FFmpeg binary with app (licensing compliance)

**Scale/Scope**:
- Project size: Support videos up to 4K resolution, projects with 100+ clips
- File sizes: Handle individual files up to 10GB
- Export duration: Videos up to 60 minutes
- Target users: Content creators, educators, tutorial makers (10k+ potential users)
- Feature scope: 7 user stories (3 MVP, 4 enhanced features) with 69 functional requirements

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Pre-Phase 0 Check: ✅ PASSED

**Security & Secrets Management**
- ✅ No secrets, API keys, or credentials required for core functionality
- ✅ Cloud export (stretch goal) will require user-configured OAuth tokens (not handled in app)
- ✅ FFmpeg bundled as binary, no external service dependencies

**Memory Bank Management**
- ✅ No memory bank exists yet (new project)
- ⚠️ **Action**: Create memory bank after Phase 1 to document architecture decisions

**Test-Driven Development**
- ✅ Test harness planned: cargo test (Rust), Vitest (Svelte), Playwright (E2E)
- ✅ TDD workflow: Write tests for each user story before implementation
- ✅ Critical paths identified: video import, timeline operations, FFmpeg export, screen recording

**Resource Constraints Reality**
- ✅ Fast feedback: Rust unit tests (<5s), Svelte component tests (<10s)
- ✅ E2E tests target <30s per scenario
- ✅ FFmpeg operations testable with short sample videos (avoid slow integration tests)

**Simple Implementation Philosophy**
- ✅ KISS: Start with single-track timeline, add multi-track in P3
- ✅ Minimal dependencies: Tauri + Svelte + FFmpeg covers 90% of needs
- ✅ Progressive enhancement: MVP (P1) → Recording (P2) → Advanced (P3-P5)

**Continuous Integration & Delivery**
- ✅ CI/CD from day one: GitHub Actions workflow planned
- ✅ Local validation: `cargo test`, `cargo clippy`, `npm test`, `npm run build` before commits
- ✅ Platform-specific: macOS and Windows runners for cross-platform validation

### Potential Violations: NONE

No constitution violations detected. Project aligns with all core principles.

## Project Structure

### Documentation (this feature)

```text
specs/001-clipforge/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output: Technology research and decisions
├── data-model.md        # Phase 1 output: Entity models and relationships
├── quickstart.md        # Phase 1 output: Setup and development guide
├── contracts/           # Phase 1 output: API contracts (Tauri commands)
│   └── tauri-commands.md
├── checklists/
│   └── requirements.md  # Spec validation checklist (already created)
└── spec.md              # Feature specification (already created)
```

### Source Code (repository root)

```text
clipforge/
├── src-tauri/                  # Rust backend (Tauri)
│   ├── src/
│   │   ├── main.rs            # Tauri app entry point
│   │   ├── commands/          # Tauri command handlers
│   │   │   ├── mod.rs
│   │   │   ├── media.rs       # Import, thumbnail generation
│   │   │   ├── playback.rs    # Video playback controls
│   │   │   ├── timeline.rs    # Timeline state management
│   │   │   ├── export.rs      # FFmpeg export operations
│   │   │   └── recording.rs   # Screen/webcam recording
│   │   ├── ffmpeg/            # FFmpeg integration
│   │   │   ├── mod.rs
│   │   │   ├── transcoder.rs  # Video encoding/decoding
│   │   │   ├── thumbnails.rs  # Thumbnail extraction
│   │   │   └── export.rs      # Export pipeline
│   │   ├── models/            # Data models
│   │   │   ├── mod.rs
│   │   │   ├── project.rs     # Project state
│   │   │   ├── clip.rs        # Video clip metadata
│   │   │   └── timeline.rs    # Timeline structure
│   │   ├── storage/           # Persistence layer
│   │   │   ├── mod.rs
│   │   │   ├── project_io.rs  # Project save/load
│   │   │   └── cache.rs       # Media cache management
│   │   └── platform/          # Platform-specific APIs
│   │       ├── mod.rs
│   │       ├── macos.rs       # macOS screen recording (AVFoundation)
│   │       └── windows.rs     # Windows screen recording (Windows.Graphics.Capture)
│   ├── Cargo.toml
│   └── tauri.conf.json        # Tauri configuration
│
├── src/                        # Svelte frontend
│   ├── lib/
│   │   ├── components/        # Svelte components
│   │   │   ├── MediaLibrary.svelte
│   │   │   ├── Timeline.svelte
│   │   │   ├── VideoPreview.svelte
│   │   │   ├── ExportDialog.svelte
│   │   │   ├── RecordingControls.svelte
│   │   │   └── TrackView.svelte
│   │   ├── canvas/            # Canvas-based timeline renderer
│   │   │   ├── timeline-renderer.ts
│   │   │   ├── clip-renderer.ts
│   │   │   └── playhead-renderer.ts
│   │   ├── stores/            # Svelte stores (state management)
│   │   │   ├── project.ts
│   │   │   ├── timeline.ts
│   │   │   ├── media-library.ts
│   │   │   └── playback.ts
│   │   ├── services/          # Frontend services
│   │   │   ├── tauri-api.ts   # Tauri command wrappers
│   │   │   └── video-player.ts
│   │   └── types/             # TypeScript type definitions
│   │       ├── project.ts
│   │       ├── clip.ts
│   │       └── timeline.ts
│   ├── routes/                # SvelteKit routes (if using SvelteKit)
│   │   └── +page.svelte       # Main app page
│   ├── App.svelte             # Root component (if not using SvelteKit)
│   └── main.ts                # Frontend entry point
│
├── tests/                      # Integration and E2E tests
│   ├── integration/           # Integration tests (Rust)
│   │   ├── ffmpeg_pipeline_test.rs
│   │   ├── project_io_test.rs
│   │   └── timeline_test.rs
│   ├── e2e/                   # End-to-end tests (Playwright)
│   │   ├── import.spec.ts
│   │   ├── timeline-editing.spec.ts
│   │   ├── export.spec.ts
│   │   └── recording.spec.ts
│   └── fixtures/              # Test video files
│       ├── sample-1080p.mp4
│       └── sample-720p.mov
│
├── .github/
│   └── workflows/
│       └── ci.yml             # CI/CD pipeline (GitHub Actions)
│
├── package.json               # Node.js dependencies (Svelte, Vite)
├── vite.config.ts             # Vite bundler config
├── tsconfig.json              # TypeScript config
├── playwright.config.ts       # Playwright E2E test config
└── README.md                  # Project documentation
```

**Structure Decision**: 

This is a **desktop application** using Tauri's hybrid architecture. The Rust backend (`src-tauri/`) handles performance-critical operations (FFmpeg integration, file I/O, system APIs for screen recording), while the Svelte frontend (`src/`) provides the reactive UI. This structure separates concerns:

- **Rust backend**: Media processing, native OS APIs, storage
- **Svelte frontend**: UI components, timeline canvas rendering, user interactions
- **Tauri bridge**: Commands expose Rust functions to frontend via async IPC

The single-project structure (not multi-project) is appropriate because frontend and backend are tightly coupled as a single desktop application binary. Tests are organized by type (unit tests alongside code, integration tests in `tests/`, E2E tests in `tests/e2e/`).

## Complexity Tracking

> **No violations detected - section not applicable**

Project adheres to all constitution principles without requiring complexity justifications.

---

## Phase 0 Complete ✅

**Status**: COMPLETE  
**Date**: 2025-10-27

**Deliverables**:
- ✅ `research.md`: Technology stack validated, all decisions documented
- ✅ All NEEDS CLARIFICATION items resolved
- ✅ FFmpeg integration strategy defined
- ✅ Platform-specific recording approaches researched
- ✅ Performance optimization strategies documented
- ✅ Security considerations addressed

**Key Decisions**:
1. **Desktop Framework**: Tauri 1.5+ (native performance, small bundle)
2. **Frontend**: Svelte 4.0+ with TypeScript (reactive, performant)
3. **Media Processing**: FFmpeg 6.0+ CLI (industry standard, comprehensive)
4. **Timeline UI**: HTML5 Canvas (60fps rendering capability)
5. **Storage**: JSON projects + SQLite cache (simple, queryable)

**No Blockers**: Ready for Phase 1

---

## Phase 1 Complete ✅

**Status**: COMPLETE  
**Date**: 2025-10-27

**Deliverables**:
- ✅ `data-model.md`: 8 core entities + 2 embedded objects defined
- ✅ `contracts/tauri-commands.md`: 28 Tauri commands documented
- ✅ `quickstart.md`: Development environment setup guide
- ✅ Agent context updated (Cursor IDE)

**Entity Model Summary**:
- **Project**: Timeline state, media library, export settings
- **MediaClip**: Imported video metadata, thumbnails, proxies
- **TimelineClip**: Clip instances on timeline with edit decisions
- **Track**: Timeline layers (main + overlay)
- **RecordingSession**: Screen/webcam recording state
- **Caption**: Timestamped subtitles
- **Effect**: Visual/audio modifications
- **ExportSettings**: Rendering configuration

**API Contracts**: 28 commands across 7 categories (media, playback, timeline, project, export, recording, effects)

**No Blockers**: Ready for Phase 2 (tasks generation)

---

## Constitution Check (Post-Phase 1): ✅ PASSED

### Re-validation After Design

**Security & Secrets Management**
- ✅ No secrets in data model or API contracts
- ✅ File paths validated before FFmpeg operations
- ✅ Command injection prevented (Rust command builders)

**Memory Bank Management**
- ⚠️ **Action Required**: Create memory bank after initial implementation
- Document: Architecture decisions, FFmpeg patterns, Canvas optimizations

**Test-Driven Development**
- ✅ Test structure defined in project layout
- ✅ Unit tests (cargo test), component tests (Vitest), E2E tests (Playwright)
- ✅ Test fixtures directory planned

**Resource Constraints Reality**
- ✅ Fast feedback loops: <5s Rust tests, <10s frontend tests, <30s E2E
- ✅ Short sample videos for integration tests

**Simple Implementation Philosophy**
- ✅ MVP scope clear (P1: import → edit → export)
- ✅ Progressive enhancement (P2: recording, P3+: advanced features)
- ✅ Minimal dependencies (Tauri + Svelte + FFmpeg core stack)

**Continuous Integration & Delivery**
- ✅ CI/CD pipeline defined (GitHub Actions, macOS + Windows)
- ✅ Local validation checklist in quickstart guide
- ✅ Pre-commit validation script documented

### Final Assessment

**Status**: ✅ **ALL GATES PASSED**

No constitution violations. Design maintains alignment with all core principles.

**Recommendations**:
1. Set up CI/CD pipeline immediately after project init
2. Write tests for media import first (TDD approach)
3. Create memory bank after MVP implementation

---

## Next Steps

**Ready for**: `/speckit.tasks` command to generate task breakdown

**Implementation Order** (recommended):
1. **Phase 1: Setup** (T001-T003)
   - Initialize Tauri project
   - Set up Svelte frontend
   - Configure CI/CD pipeline

2. **Phase 2: MVP - User Story 1** (Import & Playback)
   - Media import commands
   - Thumbnail generation
   - Video preview component

3. **Phase 3: MVP - User Story 2** (Timeline Editing)
   - Timeline state management
   - Canvas timeline renderer
   - Trim, split, delete operations

4. **Phase 4: MVP - User Story 3** (Export)
   - FFmpeg export pipeline
   - Progress tracking
   - Multi-clip concat

5. **Phase 5+**: Enhanced features (P2-P5 user stories)


---

## Summary

**Planning Phase**: COMPLETE ✅

**Documents Generated**:
1. ✅ `plan.md` (this file) - Implementation plan with tech stack
2. ✅ `research.md` - Technology decisions and rationale
3. ✅ `data-model.md` - Entity models and relationships
4. ✅ `contracts/tauri-commands.md` - API contracts
5. ✅ `quickstart.md` - Development setup guide

**Total Pages**: ~100 pages of design documentation

**Constitution Compliance**: 100% (all principles validated)

**Blockers**: NONE

**Status**: Ready for task generation and implementation 🚀
