# Implementation Plan: ClipForge Desktop Video Editor

**Branch**: `001-clipforge` | **Date**: 2025-10-27 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-clipforge/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command and guides implementation from requirements to working code.

## Summary

ClipForge is a native desktop video editor that enables creators to record (screen/webcam), import video files, edit on a timeline, and export professional videos. The MVP focuses on import ‚Üí edit ‚Üí export workflow, with recording and advanced features in subsequent phases. Built with Tauri for native performance, Svelte for reactive UI, and FFmpeg for media processing.

**Technical Approach**: Tauri provides cross-platform desktop capabilities with Rust backend for performance-critical operations (FFmpeg integration, file I/O, system APIs). Svelte frontend delivers reactive timeline UI with HTML5 Canvas for efficient rendering. Media processing leverages FFmpeg CLI invoked from Rust for transcoding, export, and effects.

## Technical Context

**Language/Version**: Rust 1.75+ (Tauri backend), TypeScript 5.0+ with Svelte 4.0+ (frontend)

**Primary Dependencies**:
- **Tauri 1.5+**: Desktop framework (Rust backend + web frontend)
- **Svelte 4.0+**: Reactive frontend framework
- **FFmpeg 6.0+**: Media processing (CLI invoked from Rust)
- **HTML5 Canvas API**: Custom timeline renderer
- **HTML5 Video Element**: Video preview and playback
- **tokio**: Async runtime for Rust (FFmpeg process management)
- **serde**: Rust serialization for Tauri commands
- **tauri-plugin-fs-extra**: Enhanced filesystem operations
- **tauri-plugin-dialog**: Native file picker dialogs

**Storage**: 
- **Project files**: JSON format storing timeline state, clip references, edit decisions (stored on local filesystem)
- **Media cache**: Thumbnail images and proxy videos (SQLite database for metadata, files on disk)
- **Auto-save**: Periodic JSON snapshots to prevent data loss

**Testing**:
- **Rust backend**: `cargo test` for unit tests, integration tests for FFmpeg pipelines
- **Frontend**: Vitest for component tests, Playwright for E2E tests
- **CI/CD**: GitHub Actions with platform-specific runners (macOS, Windows)

**Target Platform**: 
- **Primary**: macOS 11+ (Intel + Apple Silicon)
- **Secondary**: Windows 10+ (x64)
- **Future**: Linux (Ubuntu 20.04+)

**Project Type**: Desktop application (Tauri hybrid architecture - Rust + Svelte frontend)

**Performance Goals**:
- Timeline UI: 60 fps rendering, sub-100ms interaction response
- Video playback: 30+ fps for 1080p, 24+ fps for 4K
- Export: Real-time encoding (1 minute video exports in ~1 minute at 1080p)
- App launch: Under 5 seconds cold start
- Memory: Under 2GB for typical editing sessions

**Constraints**:
- Cross-platform: Must build and run identically on macOS and Windows
- Offline-first: No network requirements for core editing (cloud export optional)
- Native performance: Timeline must handle 50+ clips without lag
- Disk I/O: Efficient caching to minimize SSD wear during scrubbing
- FFmpeg bundling: Ship static FFmpeg binary with app (licensing compliance)

**Scale/Scope**:
- Project size: Support videos up to 4K resolution, projects with 100+ clips
- File sizes: Handle individual files up to 10GB
- Export duration: Videos up to 60 minutes
- Target users: Content creators, educators, tutorial makers (10k+ potential users)
- Feature scope: 7 user stories (3 MVP, 4 enhanced features) with 69 functional requirements

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Pre-Phase 0 Check: ‚úÖ PASSED

**Security & Secrets Management**
- ‚úÖ No secrets, API keys, or credentials required for core functionality
- ‚úÖ Cloud export (stretch goal) will require user-configured OAuth tokens (not handled in app)
- ‚úÖ FFmpeg bundled as binary, no external service dependencies

**Memory Bank Management**
- ‚úÖ No memory bank exists yet (new project)
- ‚ö†Ô∏è **Action**: Create memory bank after Phase 1 to document architecture decisions

**Test-Driven Development**
- ‚úÖ Test harness planned: cargo test (Rust), Vitest (Svelte), Playwright (E2E)
- ‚úÖ TDD workflow: Write tests for each user story before implementation
- ‚úÖ Critical paths identified: video import, timeline operations, FFmpeg export, screen recording

**Resource Constraints Reality**
- ‚úÖ Fast feedback: Rust unit tests (<5s), Svelte component tests (<10s)
- ‚úÖ E2E tests target <30s per scenario
- ‚úÖ FFmpeg operations testable with short sample videos (avoid slow integration tests)

**Simple Implementation Philosophy**
- ‚úÖ KISS: Start with single-track timeline, add multi-track in P3
- ‚úÖ Minimal dependencies: Tauri + Svelte + FFmpeg covers 90% of needs
- ‚úÖ Progressive enhancement: MVP (P1) ‚Üí Recording (P2) ‚Üí Advanced (P3-P5)

**Continuous Integration & Delivery**
- ‚úÖ CI/CD from day one: GitHub Actions workflow planned
- ‚úÖ Local validation: `cargo test`, `cargo clippy`, `npm test`, `npm run build` before commits
- ‚úÖ Platform-specific: macOS and Windows runners for cross-platform validation

### Potential Violations: NONE

No constitution violations detected. Project aligns with all core principles.

## Project Structure

### Documentation (this feature)

```text
specs/001-clipforge/
‚îú‚îÄ‚îÄ plan.md              # This file (/speckit.plan command output)
‚îú‚îÄ‚îÄ research.md          # Phase 0 output: Technology research and decisions
‚îú‚îÄ‚îÄ data-model.md        # Phase 1 output: Entity models and relationships
‚îú‚îÄ‚îÄ quickstart.md        # Phase 1 output: Setup and development guide
‚îú‚îÄ‚îÄ contracts/           # Phase 1 output: API contracts (Tauri commands)
‚îÇ   ‚îî‚îÄ‚îÄ tauri-commands.md
‚îú‚îÄ‚îÄ checklists/
‚îÇ   ‚îî‚îÄ‚îÄ requirements.md  # Spec validation checklist (already created)
‚îî‚îÄ‚îÄ spec.md              # Feature specification (already created)
```

### Source Code (repository root)

```text
clipforge/
‚îú‚îÄ‚îÄ src-tauri/                  # Rust backend (Tauri)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.rs            # Tauri app entry point
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands/          # Tauri command handlers
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ media.rs       # Import, thumbnail generation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ playback.rs    # Video playback controls
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ timeline.rs    # Timeline state management
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ export.rs      # FFmpeg export operations
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ recording.rs   # Screen/webcam recording
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ffmpeg/            # FFmpeg integration
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transcoder.rs  # Video encoding/decoding
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ thumbnails.rs  # Thumbnail extraction
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ export.rs      # Export pipeline
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/            # Data models
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ project.rs     # Project state
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ clip.rs        # Video clip metadata
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ timeline.rs    # Timeline structure
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ storage/           # Persistence layer
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ project_io.rs  # Project save/load
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache.rs       # Media cache management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ platform/          # Platform-specific APIs
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ macos.rs       # macOS screen recording (AVFoundation)
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ windows.rs     # Windows screen recording (Windows.Graphics.Capture)
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ tauri.conf.json        # Tauri configuration
‚îÇ
‚îú‚îÄ‚îÄ src/                        # Svelte frontend
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/        # Svelte components
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MediaLibrary.svelte
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Timeline.svelte
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VideoPreview.svelte
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExportDialog.svelte
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RecordingControls.svelte
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TrackView.svelte
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ canvas/            # Canvas-based timeline renderer
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ timeline-renderer.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ clip-renderer.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ playhead-renderer.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stores/            # Svelte stores (state management)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ project.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ timeline.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ media-library.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ playback.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/          # Frontend services
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tauri-api.ts   # Tauri command wrappers
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ video-player.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/             # TypeScript type definitions
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ project.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ clip.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ timeline.ts
‚îÇ   ‚îú‚îÄ‚îÄ routes/                # SvelteKit routes (if using SvelteKit)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ +page.svelte       # Main app page
‚îÇ   ‚îú‚îÄ‚îÄ App.svelte             # Root component (if not using SvelteKit)
‚îÇ   ‚îî‚îÄ‚îÄ main.ts                # Frontend entry point
‚îÇ
‚îú‚îÄ‚îÄ tests/                      # Integration and E2E tests
‚îÇ   ‚îú‚îÄ‚îÄ integration/           # Integration tests (Rust)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ffmpeg_pipeline_test.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ project_io_test.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ timeline_test.rs
‚îÇ   ‚îú‚îÄ‚îÄ e2e/                   # End-to-end tests (Playwright)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ import.spec.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ timeline-editing.spec.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ export.spec.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ recording.spec.ts
‚îÇ   ‚îî‚îÄ‚îÄ fixtures/              # Test video files
‚îÇ       ‚îú‚îÄ‚îÄ sample-1080p.mp4
‚îÇ       ‚îî‚îÄ‚îÄ sample-720p.mov
‚îÇ
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ ci.yml             # CI/CD pipeline (GitHub Actions)
‚îÇ
‚îú‚îÄ‚îÄ package.json               # Node.js dependencies (Svelte, Vite)
‚îú‚îÄ‚îÄ vite.config.ts             # Vite bundler config
‚îú‚îÄ‚îÄ tsconfig.json              # TypeScript config
‚îú‚îÄ‚îÄ playwright.config.ts       # Playwright E2E test config
‚îî‚îÄ‚îÄ README.md                  # Project documentation
```

**Structure Decision**: 

This is a **desktop application** using Tauri's hybrid architecture. The Rust backend (`src-tauri/`) handles performance-critical operations (FFmpeg integration, file I/O, system APIs for screen recording), while the Svelte frontend (`src/`) provides the reactive UI. This structure separates concerns:

- **Rust backend**: Media processing, native OS APIs, storage
- **Svelte frontend**: UI components, timeline canvas rendering, user interactions
- **Tauri bridge**: Commands expose Rust functions to frontend via async IPC

The single-project structure (not multi-project) is appropriate because frontend and backend are tightly coupled as a single desktop application binary. Tests are organized by type (unit tests alongside code, integration tests in `tests/`, E2E tests in `tests/e2e/`).

## Complexity Tracking

> **No violations detected - section not applicable**

Project adheres to all constitution principles without requiring complexity justifications.

---

## Phase 0 Complete ‚úÖ

**Status**: COMPLETE  
**Date**: 2025-10-27

**Deliverables**:
- ‚úÖ `research.md`: Technology stack validated, all decisions documented
- ‚úÖ All NEEDS CLARIFICATION items resolved
- ‚úÖ FFmpeg integration strategy defined
- ‚úÖ Platform-specific recording approaches researched
- ‚úÖ Performance optimization strategies documented
- ‚úÖ Security considerations addressed

**Key Decisions**:
1. **Desktop Framework**: Tauri 1.5+ (native performance, small bundle)
2. **Frontend**: Svelte 4.0+ with TypeScript (reactive, performant)
3. **Media Processing**: FFmpeg 6.0+ CLI (industry standard, comprehensive)
4. **Timeline UI**: HTML5 Canvas (60fps rendering capability)
5. **Storage**: JSON projects + SQLite cache (simple, queryable)

**No Blockers**: Ready for Phase 1

---

## Phase 1 Complete ‚úÖ

**Status**: COMPLETE  
**Date**: 2025-10-27

**Deliverables**:
- ‚úÖ `data-model.md`: 8 core entities + 2 embedded objects defined
- ‚úÖ `contracts/tauri-commands.md`: 28 Tauri commands documented
- ‚úÖ `quickstart.md`: Development environment setup guide
- ‚úÖ Agent context updated (Cursor IDE)

**Entity Model Summary**:
- **Project**: Timeline state, media library, export settings
- **MediaClip**: Imported video metadata, thumbnails, proxies
- **TimelineClip**: Clip instances on timeline with edit decisions
- **Track**: Timeline layers (main + overlay)
- **RecordingSession**: Screen/webcam recording state
- **Caption**: Timestamped subtitles
- **Effect**: Visual/audio modifications
- **ExportSettings**: Rendering configuration

**API Contracts**: 28 commands across 7 categories (media, playback, timeline, project, export, recording, effects)

**No Blockers**: Ready for Phase 2 (tasks generation)

---

## Constitution Check (Post-Phase 1): ‚úÖ PASSED

### Re-validation After Design

**Security & Secrets Management**
- ‚úÖ No secrets in data model or API contracts
- ‚úÖ File paths validated before FFmpeg operations
- ‚úÖ Command injection prevented (Rust command builders)

**Memory Bank Management**
- ‚ö†Ô∏è **Action Required**: Create memory bank after initial implementation
- Document: Architecture decisions, FFmpeg patterns, Canvas optimizations

**Test-Driven Development**
- ‚úÖ Test structure defined in project layout
- ‚úÖ Unit tests (cargo test), component tests (Vitest), E2E tests (Playwright)
- ‚úÖ Test fixtures directory planned

**Resource Constraints Reality**
- ‚úÖ Fast feedback loops: <5s Rust tests, <10s frontend tests, <30s E2E
- ‚úÖ Short sample videos for integration tests

**Simple Implementation Philosophy**
- ‚úÖ MVP scope clear (P1: import ‚Üí edit ‚Üí export)
- ‚úÖ Progressive enhancement (P2: recording, P3+: advanced features)
- ‚úÖ Minimal dependencies (Tauri + Svelte + FFmpeg core stack)

**Continuous Integration & Delivery**
- ‚úÖ CI/CD pipeline defined (GitHub Actions, macOS + Windows)
- ‚úÖ Local validation checklist in quickstart guide
- ‚úÖ Pre-commit validation script documented

### Final Assessment

**Status**: ‚úÖ **ALL GATES PASSED**

No constitution violations. Design maintains alignment with all core principles.

**Recommendations**:
1. Set up CI/CD pipeline immediately after project init
2. Write tests for media import first (TDD approach)
3. Create memory bank after MVP implementation

---

## Next Steps

**Ready for**: `/speckit.tasks` command to generate task breakdown

**Implementation Order** (recommended):
1. **Phase 1: Setup** (T001-T003)
   - Initialize Tauri project
   - Set up Svelte frontend
   - Configure CI/CD pipeline

2. **Phase 2: MVP - User Story 1** (Import & Playback)
   - Media import commands
   - Thumbnail generation
   - Video preview component

3. **Phase 3: MVP - User Story 2** (Timeline Editing)
   - Timeline state management
   - Canvas timeline renderer
   - Trim, split, delete operations

4. **Phase 4: MVP - User Story 3** (Export)
   - FFmpeg export pipeline
   - Progress tracking
   - Multi-clip concat

5. **Phase 5+**: Enhanced features (P2-P5 user stories)


---

## Summary

**Planning Phase**: COMPLETE ‚úÖ

**Documents Generated**:
1. ‚úÖ `plan.md` (this file) - Implementation plan with tech stack
2. ‚úÖ `research.md` - Technology decisions and rationale
3. ‚úÖ `data-model.md` - Entity models and relationships
4. ‚úÖ `contracts/tauri-commands.md` - API contracts
5. ‚úÖ `quickstart.md` - Development setup guide

**Total Pages**: ~100 pages of design documentation

**Constitution Compliance**: 100% (all principles validated)

**Blockers**: NONE

**Status**: Ready for task generation and implementation üöÄ
